{"version":3,"file":"static/chunks/pages/[[...slug]]-67b8869a1946a01d.js","mappings":"saACA,CAAAA,OAAAC,QAAA,CAAAD,OAAAC,QAAA,MAAAC,IAAA,EACA,eACA,WACA,OAAeC,EAAQ,MACvB,EACA,sGCgJAC,CAAAA,EAAA,QAAeC,EAAAA,CAAIA","sources":["webpack://_N_E/?33d6","webpack://_N_E/./src/pages/[[...slug]].tsx"],"sourcesContent":["\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/[[...slug]]\",\n      function () {\n        return require(\"private-next-pages/[[...slug]].tsx\");\n      }\n    ]);\n    if(module.hot) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/[[...slug]]\"])\n      });\n    }\n  ","import { upgradeToDocsConfig } from '@mintlify/validation';\nimport type { GetStaticPaths, GetStaticProps } from 'next';\nimport type { ParsedUrlQuery } from 'querystring';\n\nimport { getMdx } from '@/data-fetching/getMdx';\nimport { getRedirect } from '@/data-fetching/getRedirect';\nimport { getLocalPageProps, PagePropType } from '@/lib/local/page';\nimport { getFiles, getPathsStream } from '@/lib/local/paths';\nimport { PageProps } from '@/types/page';\nimport { StaticProps } from '@/types/staticProps';\nimport Page from '@/ui/Page';\nimport { applyLegacyThemeConfigs } from '@/utils/applyLegacyThemeConfigs';\nimport { getDynamicTailwindCss, getTailwindSelectors } from '@/utils/getDynamicTailwindCss';\nimport { isIndexRoute, pathsAreEquivalent } from '@/utils/path';\nimport { prepareToSerialize } from '@/utils/staticProps/prepareToSerialize';\nimport { serializeContent } from '@/utils/staticProps/serializeContent';\n\ninterface PathProps extends ParsedUrlQuery {\n  slug?: string[];\n}\n\nexport const getStaticPaths: GetStaticPaths<PathProps> = async () => {\n  const paths: {\n    params: {\n      slug: string[];\n    };\n  }[] = [];\n\n  const files = getFiles('src/_props');\n\n  // With appdir + Server components we can stream on first load and cache data soon.\n  for await (const path of getPathsStream(files)) {\n    paths.push(path);\n  }\n  return {\n    paths,\n    fallback: 'blocking',\n  };\n};\n\nexport const getStaticProps: GetStaticProps<PageProps, PathProps> = async ({ params }) => {\n  if (!params) throw new Error('No path parameters found');\n\n  const { slug } = params;\n  const slugStr = slug ? slug.join('/') : 'index'; // TODO index logic\n\n  if (slug && slug[0] === 'api') {\n    throw new Error('Path /api is a reserved path and cannot be used for a page.');\n  }\n  const result = await getLocalStaticProps(slugStr);\n  if (\n    'redirect' in result &&\n    pathsAreEquivalent(slugStr, result.redirect.destination) &&\n    !isIndexRoute(slugStr)\n  ) {\n    return await getLocalStaticProps(`${result.redirect.destination}/index`);\n  } else {\n    return result;\n  }\n};\n\nconst PageNotFound: { notFound: true } = { notFound: true };\n\nconst getLocalStaticProps = async (slug: string): Promise<StaticProps> => {\n  const data: PagePropType = await getLocalPageProps(slug);\n\n  if (data.hasOwnProperty('notFound')) {\n    return PageNotFound;\n  }\n\n  // Only returns docsNavWithMetadata when we need to redirect\n  if ('docsNavWithMetadata' in data && 'docsConfig' in data) {\n    const { docsNavWithMetadata, docsConfig } = data;\n\n    const redirect = getRedirect(\n      slug,\n      docsConfig.redirects,\n      docsNavWithMetadata,\n      docsConfig.errors?.[404]?.redirect === false && slug !== 'index'\n    );\n    if (redirect) {\n      const { destination } = redirect;\n      return { redirect: { destination, permanent: false } };\n    }\n\n    console.warn('Could not find a page to redirect to.');\n    return {\n      notFound: true,\n    };\n  }\n\n  if ('content' in data && 'pageData' in data && 'favicons' in data) {\n    try {\n      const { content, pageData, favicons, snippets, cssFiles, jsFiles } = data;\n      const { pageMetadata, mintConfig, docsConfig: docsConfiguration } = pageData;\n\n      const description = await serializeContent(pageMetadata.description);\n\n      const mintConfigWithDefaultThemeConfigs = mintConfig\n        ? applyLegacyThemeConfigs(mintConfig)\n        : undefined;\n\n      const docsConfig = mintConfigWithDefaultThemeConfigs\n        ? upgradeToDocsConfig(mintConfigWithDefaultThemeConfigs)\n        : docsConfiguration;\n\n      const tailwindSelectors = await getTailwindSelectors({ content });\n\n      const { mdxSource, mdxSourceWithNoJs, mdxExtracts, panelMdxSource, panelMdxSourceWithNoJs } =\n        await getMdx(slug, content, pageMetadata, snippets, 'local', docsConfig, tailwindSelectors);\n\n      const banner = await serializeContent(docsConfig.banner?.content);\n\n      const dynamicTailwindCss = await getDynamicTailwindCss({\n        content: mdxSource.compiledSource + (panelMdxSource?.compiledSource ?? ''),\n      });\n      if (dynamicTailwindCss) {\n        cssFiles.push({ content: dynamicTailwindCss });\n      }\n\n      const pageProps: PageProps = {\n        mdxSource,\n        mdxExtracts,\n        panelMdxSource,\n        panelMdxSourceWithNoJs,\n        // This is the description of the page that can contain markdown and is different from the one in `pageMetadata`.\n        description,\n        pageData: {\n          ...pageData,\n          apiReferenceData: pageData.apiReferenceData ?? {},\n          mintConfig: mintConfigWithDefaultThemeConfigs,\n          docsConfig,\n        },\n        favicons: favicons ?? { icons: [], browserconfig: '/favicons/browserconfig.xml' },\n        cssFiles,\n        jsFiles,\n        mdxSourceWithNoJs,\n        banner,\n      };\n      return {\n        props: prepareToSerialize(pageProps),\n      };\n    } catch (err) {\n      console.warn(err);\n      return PageNotFound;\n    }\n  }\n  return PageNotFound;\n};\n\nexport default Page;\n"],"names":["window","__NEXT_P","push","__webpack_require__","__webpack_exports__","Page"],"sourceRoot":""}